#!/usr/bin/env python3
"""
gen-compose-override.py — generates compose.bricks.override.yml and updates BRICK_PATHS in .env
- Source: HOST_BRICK_PATHS (comma-separated) from .env
- Mapping: /bricks/brick1..N inside the container + BRICK_PATHS=/bricks/brick1,...
- Safety: no environment merges in YAML; override adds volumes only.
"""

import os, sys, textwrap, re
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
ENV_FILE = ROOT / ".env"
ENV_OVERRIDE = None  # deprecated
OUT_FILE = ROOT / "compose.bricks.override.yml"
COMPOSE_FILE = ROOT / "docker-compose.yml"

# Load .env (no external libs)
def parse_dotenv(path):
    env = {}
    if path.exists():
        for line in path.read_text(encoding="utf-8").splitlines():
            if not line or line.strip().startswith("#"):
                continue
            if "=" in line:
                k,v = line.split("=",1)
                env[k.strip()] = v.strip()
    return env

def detect_service_name(compose_text):
    # naive detection: find first service key under 'services:'
    lines = compose_text.splitlines()
    in_services = False
    for i, ln in enumerate(lines):
        if re.match(r'^\s*services:\s*$', ln):
            in_services = True
            continue
        if in_services:
            m = re.match(r'^\s{2,}([A-Za-z0-9._-]+):\s*$', ln)
            if m:
                return m.group(1)
            # stop at next top-level block
            if re.match(r'^[A-Za-z_].*:\s*$', ln):
                break
    return "gluster-solo"

env = dict(os.environ)
env.update(parse_dotenv(ENV_FILE))

raw = env.get("HOST_BRICK_PATHS", "").strip()  # Source paths of host bricks
if not raw:
    print("ERROR: HOST_BRICK_PATHS ist leer. Beispiel: HOST_BRICK_PATHS=/mnt/disk1/brick1,/mnt/disk2/brick2", file=sys.stderr)
    sys.exit(2)

# Split and clean
paths = [p.strip() for p in raw.split(",") if p.strip()]
if not paths:
    print("ERROR: Keine gültigen Pfade in HOST_BRICK_PATHS gefunden.", file=sys.stderr)
    sys.exit(2)

# Validate absolute-ish
for p in paths:
    if not p.startswith("/") and not re.match(r"^[A-Za-z]:\\", p):
        print(f"WARN: '{p}' ist kein absoluter Pfad.", file=sys.stderr)

brick_targets = [f"/bricks/brick{i+1}" for i in range(len(paths))]
brick_paths_env = ",".join(brick_targets)

# Write .env to inject BRICK_PATHS without touching 'environment:' merge semantics
ENV_OVERRIDE.write_text(f"BRICK_PATHS={brick_paths_env}\n", encoding="utf-8")

# Detect service name
compose_text = COMPOSE_FILE.read_text(encoding="utf-8")
service_name = detect_service_name(compose_text)

# Render volumes override only
vol_items = []
for idx, src in enumerate(paths, start=1):
    item = textwrap.dedent(f"""            - type: bind
          source: {src}
          target: /bricks/brick{idx}
          bind:
            create_host_path: true  # create missing host paths automatically (engine-dependent)
    """)
    vol_items.append(item)

volumes_yaml = "".join(vol_items)

content = textwrap.dedent(f"""    # Auto-generated by scripts/gen-compose-override.py
services:
  {service_name}:
    volumes:
{textwrap.indent(volumes_yaml, ' ' * 8)}
""")

OUT_FILE.write_text(content, encoding="utf-8")
print(f"geschrieben: {OUT_FILE}")
print(f"geschrieben: {ENV_OVERRIDE}")
print(f"BRICK_PATHS={brick_paths_env}")
