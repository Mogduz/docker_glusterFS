#!/usr/bin/env python3
import os, sys, textwrap, pathlib, re
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
ENV_FILE = ROOT / ".env"
OUT_FILE = ROOT / "compose.bricks.override.yml"

def parse_dotenv(path):
    env = {}
    if path.exists():
        for line in path.read_text(encoding="utf-8").splitlines():
            if not line or line.strip().startswith("#"): 
                continue
            if "=" in line:
                k,v = line.split("=",1)
                env[k.strip()] = v.strip()
    return env

env = dict(os.environ)
env.update(parse_dotenv(ENV_FILE))

raw = env.get("HOST_BRICK_PATHS","").strip()
if not raw:
    print("ERROR: HOST_BRICK_PATHS ist leer. Beispiel: HOST_BRICK_PATHS=/mnt/disk1/brick1,/mnt/disk2/brick2", file=sys.stderr)
    sys.exit(2)

# Split on commas, strip spaces
paths = [p.strip() for p in raw.split(",") if p.strip()]
if not paths:
    print("ERROR: Keine g√ºltigen Pfade in HOST_BRICK_PATHS gefunden.", file=sys.stderr)
    sys.exit(2)

# Validate absolute paths (at least start with /). We do not create them here; Docker will with create_host_path if supported.
for p in paths:
    if not p.startswith("/") and not re.match(r"^[A-Za-z]:\\", p):
        print(f"WARN: '{p}' ist kein absoluter Pfad. Docker kann relative Pfade anlegen, empfohlen sind absolute.", file=sys.stderr)

# Build BRICK_PATHS inside the container
brick_targets = [f"/bricks/brick{i+1}" for i in range(len(paths))]
brick_paths_env = ",".join(brick_targets)

# Render override YAML
vol_items = []
for idx, src in enumerate(paths, start=1):
    item = textwrap.dedent(f"""            - type: bind
          source: {src}
          target: /bricks/brick{idx}
    """)
    vol_items.append(item)

volumes_yaml = "".join(vol_items)

content = textwrap.dedent(f"""    # Auto-generated by scripts/gen-compose-override.py
services:
  gluster:
    environment:
      BRICK_PATHS: "{brick_paths_env}"
    volumes:
{textwrap.indent(volumes_yaml, ' ' * 8)}
""")

OUT_FILE.write_text(content, encoding="utf-8")
print(f"geschrieben: {OUT_FILE}")
print(f"BRICK_PATHS={brick_paths_env}")
