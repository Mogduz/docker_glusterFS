#!/usr/bin/env bash
set -euo pipefail

# ---- Config (env) ----
MODE="${MODE:-brick}"                      # brick | init
VOLNAME="${VOLNAME:-gv0}"
REPLICA="${REPLICA:-1}"
VTYPE="${VTYPE:-replica}"                  # replica|disperse (aktuell nutzen wir replica-Pfad)
BRICK_PATH="${BRICK_PATH:-/bricks/brick1}" # Standardbrick-Pfad
BRICK_PATHS="${BRICK_PATHS:-}"             # Kommagetrennte Liste für Multi-Bricks auf EINEM Host
PEERS="${PEERS:-}"                         # Kommagetrennte Hostliste (inkl. self), 1 Brick je Host
REQUIRE_ALL_PEERS="${REQUIRE_ALL_PEERS:-1}"
ALLOW_FORCE_CREATE="${ALLOW_FORCE_CREATE:-0}"
ALLOW_EMPTY_STATE="${ALLOW_EMPTY_STATE:-0}"
AUTO_ADD_BRICK="${AUTO_ADD_BRICK:-0}"      # Nur sinnvoll bei REPLICA=1
ADD_BRICK_SET="${ADD_BRICK_SET:-}"         # Kompletter Satz in Vielfachen von REPLICA

LOG_LEVEL="${LOG_LEVEL:-INFO}"             # glusterd Log-Level
ADDRESS_FAMILY="${ADDRESS_FAMILY:-inet}"   # inet|inet6
PORT_RANGE="${PORT_RANGE:-49152-49251}"

# ---- Helpers ----
log(){ printf "[%s] [%s] %s\n" "$(date -Is)" "${1:-INFO}" "${*:2}"; }
ok(){ log OK "$@"; }
info(){ log INFO "$@"; }
warn(){ log WARN "$@"; }
err(){ log ERROR "$@"; }

# Split comma list to array: _ARR[]
to_arr(){ IFS=',' read -r -a _ARR <<< "$1"; }

# ---- glusterd ----
start_ensure_glusterd_vol() {
          local vol="/etc/glusterfs/glusterd.vol"
          mkdir -p /etc/glusterfs || true
          if [[ ! -s "$vol" ]]; then
            cat >"$vol" <<'EOF'
# Autogenerated by entrypoint
include "glusterfs-core.vol"
volume management
    type mgmt/glusterd
    option working-directory /var/lib/glusterd
    option transport.address-family inet
    option max-port 60999
end-volume
EOF
          else
            # idempotently ensure options exist (transport.address-family / max-port)
            if ! grep -q 'option[[:space:]]\+transport.address-family' "$vol"; then
              sed -i '/type mgmt\/glusterd/a\    option transport.address-family inet' "$vol"
            fi
            if ! grep -q 'option[[:space:]]\+max-port' "$vol"; then
              sed -i '/type mgmt\/glusterd/a\    option max-port 60999' "$vol"
            fi
          fi
        }

glusterd(){
  mkdir -p "$BRICK_PATH"
  if [[ -n "$BRICK_PATHS" ]]; then to_arr "$BRICK_PATHS"; for bp in "${_ARR[@]}"; do mkdir -p "$bp"; done; fi
  # optional port range & log-level
  glusterd -N --log-level "$LOG_LEVEL" &
  local pid=$!
  for i in {1..30}; do
    if pgrep -x glusterd >/dev/null 2>&1; then ok "glusterd läuft (PID=${pid})."; return 0; fi
    sleep 1
  done
  err "glusterd startete nicht rechtzeitig."; exit 1
  ensure_glusterd_vol

}

check_state_dir(){
  local cnt
  cnt=$(find /var/lib/glusterd -mindepth 1 -maxdepth 1 | wc -l || true)
  if [[ "$cnt" -lt 2 && "$ALLOW_EMPTY_STATE" -ne 1 ]]; then
    warn "/var/lib/glusterd wirkt leer – Volume-State korrekt gemountet? (ALLOW_EMPTY_STATE=1 zum Ignorieren)"
  fi
}

# ---- Peer-Handling ----
probe_peers(){
  [[ -z "$PEERS" ]] && { info "Keine PEERS definiert – Peer-Probing übersprungen"; return 0; }
  local self; self="$(hostname -s)"
  to_arr "$PEERS"
  for p in "${_ARR[@]}"; do
    [[ "$p" == "$self" ]] && continue
    info "Probe Peer: $p"
    gluster --mode=script peer probe "$p" || true
  done
}

peers_connected(){
  gluster peer status 2>/dev/null | grep -c 'Peer in Cluster (Connected)' || true
}

require_peer_quorum(){
  [[ -z "$PEERS" ]] && { info "Kein Peer-Quorum erforderlich (PEERS leer)"; return 0; }
  to_arr "$PEERS"
  local need
  if [[ "$REQUIRE_ALL_PEERS" -eq 1 ]]; then
    need=$((${#_ARR[@]} - 1)) # alle außer self
  else
    need=$(( REPLICA - 1 ))
  fi
  info "Warte auf Peer-Quorum (benötigt=$need)…"
  for i in {1..120}; do
    local okc; okc=$(peers_connected)
    if [[ "$okc" -ge "$need" ]]; then ok "Peers verbunden: $okc (benötigt: $need)"; return 0; fi
    sleep 1
  done
  warn "Quorum nicht erreicht (connected=$(peers_connected), benötigt=$need)"
  [[ "$MODE" == "init" ]] && { err "Abbruch im INIT-Modus, um Inkonsistenzen zu vermeiden."; exit 2; }
}

# ---- Volume-Checks ----
volume_exists(){ gluster volume info "$VOLNAME" >/dev/null 2>&1; }
volume_started(){ gluster volume info "$VOLNAME" 2>/dev/null | awk '/Status:/ {print $2}' | grep -q '^Started$' || return 1; }

ensure_volume_started(){
  if ! volume_started; then
    info "Starte Volume $VOLNAME…"
    gluster --mode=script volume start "$VOLNAME" || true
  fi
}

self_host(){ hostname -s; }

build_brick_list(){
  # echo a space-separated list of host:path entries
  local self; self="$(self_host)"
  if [[ -n "$BRICK_PATHS" ]]; then
    to_arr "$BRICK_PATHS"
    local out=()
    for bp in "${_ARR[@]}"; do out+=("${self}:${bp}"); done
    printf "%s\n" "${out[*]}"
    return 0
  fi
  if [[ -n "$PEERS" ]]; then
    to_arr "$PEERS"
    local out=()
    for h in "${_ARR[@]}"; do out+=("${h}:${BRICK_PATH}"); done
    printf "%s\n" "${out[*]}"
    return 0
  fi
  # Fallback: nur self + BRICK_PATH
  printf "%s:%s\n" "$self" "$BRICK_PATH"
}

local_brick_present(){
  local self; self="$(self_host)"
  gluster volume info "$VOLNAME" 2>/dev/null | grep -qE "Brick[0-9]+: ${self}:"
}

ensure_local_brick(){
  if local_brick_present; then info "Lokaler Brick ist Teil von $VOLNAME."; return 0; fi
  if [[ "$AUTO_ADD_BRICK" -eq 1 && "$REPLICA" -eq 1 ]]; then
    info "Füge lokalen Brick hinzu (REPLICA=1)…"
    gluster --mode=script volume add-brick "$VOLNAME" "$(self_host):${BRICK_PATH}" || true
  elif [[ -n "$ADD_BRICK_SET" ]]; then
    to_arr "$ADD_BRICK_SET"; local n=${#_ARR[@]}
    if (( n % REPLICA == 0 )); then
      info "Füge kompletten Brick-Satz hinzu (n=${n}, replica=${REPLICA})…"
      local bricks=()
      for h in "${_ARR[@]}"; do bricks+=("${h}:${BRICK_PATH}"); done
      gluster --mode=script volume add-brick "$VOLNAME" replica "$REPLICA" "${bricks[@]}" || true
    else
      warn "ADD_BRICK_SET=${n} ist kein Vielfaches von REPLICA=${REPLICA}; kein add-brick."
    fi
  else
    warn "Lokaler Brick NICHT Teil von $VOLNAME (kein Auto-Add für Replikate)."
  fi
}

create_volume_safely(){
  local bricks; bricks="$(build_brick_list)"
  read -r -a BR_ARR <<< "$bricks"

  local args=(volume create "$VOLNAME")
  if [[ "$VTYPE" == "replica" ]]; then
    args+=("replica" "$REPLICA")
  fi
  args+=("transport" "tcp")
  args+=("${BR_ARR[@]}")
  if [[ "$ALLOW_FORCE_CREATE" -eq 1 ]]; then
    args+=("force")
  fi

  info "Erzeuge Volume: ${args[*]}"
  gluster --mode=script "${args[@]}"
  gluster --mode=script volume start "$VOLNAME" || true

  # sinnvolle Default-Optionen
  [[ "$REPLICA" -ge 3 ]] && gluster --mode=script volume set "$VOLNAME" cluster.quorum-type auto || true
  gluster --mode=script volume set "$VOLNAME" network.ping-timeout 5 || true
  gluster --mode=script volume set "$VOLNAME" performance.client-io-threads on || true
}

# ---- Main ----
info "===== Startparameter ====="
env | sort | sed 's/^/  /' | sed -n '1,200p'

start_glusterd
check_state_dir
probe_peers
require_peer_quorum

case "$MODE" in
  brick)
    info "Modus: BRICK"
    if volume_exists; then
      ensure_volume_started
      ensure_local_brick
    else
      info "Volume $VOLNAME unbekannt (oder noch nicht synchronisiert)."
    fi
    ;;
  init)
    info "Modus: INIT"
    if volume_exists; then
      info "Volume $VOLNAME existiert bereits."
      ensure_volume_started
      ensure_local_brick
    else
      create_volume_safely
    fi
    ;;
  *)
    err "Unbekannter MODE=$MODE"; exit 1;;
esac

ok "Bereit; Folge Logs:"
exec tail -F /var/log/glusterfs/*.log
